#!/bin/bash
# Build the site.

previewLength=40
doDebug=0
. config

function getDocs
{
    cd src/site
    find . -iname '*.md'
    cd .. # TODO Is this really needed?
}

function getOutName
{
    local name="$1"
    
    if [ "$(basename "$name")" == 'README.md' ]; then
        echo "$(dirname "$name")/index.html"
    else
        echo "$name" | sed 's/md$/html/g'
    fi
}

function assertDir
{
    local name="$(dirname "$1")"
    
    if [ "$name" != '/' ]; then
        mkdir -p "$name"
    fi
}

function getDocAttribute
{
    local fileName="$1"
    local attribute="$2"
    
    data="$(grep "<!-- $attribute: " "$fileName" | sed 's/^.*<!-- //g;s/ -->$//g' | cut -d\  -f2-)"
    
    if [ "$data" != '' ]; then
        echo "$data"
    else
        echo "Didn't get any value for document attribute '$attribute' in $fileName ($(pwd))." >&2
    fi
}

function prepDocs
{
    cd build
    mkdir -p ../intermediate/{rss,html,suggested,tags,tagCombos,preview,list,feed,tagBar/tags,tagBar/bars,related} rss
    echo "Prep."
    while read -r fileIn; do
        _buildDoc "$fileIn" "Prep" &
    done
    wait
}

function _buildDoc
{
    local fileIn="$1"
    local stage="$2"
    
    # TODO Fix this upstream.
    if [ "${fileIn::12}" == 'intermediate' ]; then
        srcFile="../$fileIn"
        justTheFile="$(basename "$(dirname "$fileIn")")"
        fileIn="$justTheFile/README.md"
    else
        srcFile="../src/site/$fileIn"
    fi
    
    # Prep
    assertDir "$fileIn"
    fileOut="$(getOutName "$fileIn")"
    
    [ "$doDebug" -gt 0 ] && echo "$stage doc $fileOut."
    
    # Get the document attributes.
    myTag="$(getDocAttribute "$srcFile" 'MYTAG')"
    public="$(getDocAttribute "$srcFile" 'PUBLIC')"
    releaseDate="$(getDocAttribute "$srcFile" 'RELEASEDATE')"
    tags="$(getDocAttribute "$srcFile" 'TAGS')"
    tighterTags="$(echo "$tags" | sed 's/, /,/g')"
    uniqueTags="$(getUniqueTags "$tighterTags")"
    title="$(getDocAttribute "$srcFile" 'TITLE')"
    titleImage="$(getDocAttribute "$srcFile" 'TITLEIMAGE')"
    titleImageThumbnail="$(getImageName "$titleImage" "_thumb")"
    
    if [ "${titleImage::1}" == '/' ]; then
        titleImagePath="../src/site$titleImage"
        titleImageThumbnailPath="$titleImageThumbnail"
    else
        titleImagePath="../src/site/$myTag/$titleImage"
        titleImageThumbnailPath="/$myTag/$titleImageThumbnail"
    fi
    
    case "$stage" in
        "Prep")
            # Build intermediate stuff.
            addDocToTags "$myTag" "$releaseDate" "$uniqueTags,$myTag,all,sitemap"
            saveTagCombo "$uniqueTags"
            buildPreview "$srcFile" "../intermediate/preview/$myTag"
            buildItem "$myTag" "html" "$uniqueTags" "$titleImageThumbnailPath"
            buildItem "$myTag" "rss" "$uniqueTags"
            makeThumbnail "$titleImagePath" ".$titleImageThumbnailPath"
        ;;
        "Build")
            # Build the doc.
            cat ../src/templates/head.html > "$fileOut"
            cat "$srcFile" | videos | images "$myTag" | pandoc -f markdown -t html >> "$fileOut"
            sed -i "s#~!TITLE!~#$title#g; s#~!TITLEIMAGE!~#$titleImage#g; s#~!TAGS!~#$tags#g; s#~!RELEASEDATE!~#$releaseDate#g;" "$fileOut"
            # TODO Create a wrapper for these.
            echo "<DIV CLASS=\"recommendedItems\">" >> "$fileOut"
            echo "<DIV CLASS=\"myTags\">" >> "$fileOut"
            getTagBar "$uniqueTags" "html" >> "$fileOut"
            echo "</DIV>" >> "$fileOut"
            cat "../intermediate/list/$uniqueTags" >> "$fileOut"
            echo "</DIV>" >> "$fileOut"
            cat ../src/templates/foot.html >> "$fileOut"
        ;;
    esac
}

function buildDocs
{
    cd build
    echo "Build."
    while read -r fileIn; do
        _buildDoc "$fileIn" "Build" &
    done
    wait
}

function buildItem
{
    # This is assumed to be run within prep/build so will be in the ./build directory.
    local tag="$1"
    local type="$2"
    local tags="$3"
    local thumbnail="$4"
    local itemFileOut="../intermediate/$type/$tag"
    local tagBar="$(getTagBar "$uniqueTags" "html")"
    
    cat "../src/templates/item.$type" | \
        sed "s#~!TITLE!~#$title#g; s#~!CONTENT!~#$(cat "../intermediate/preview/$tag")#g; s#~!RELEASEDATE!~#$releaseDate#g; s#~!SITEURL!~#$siteURL#g; s#~!MYTAG!~#$tag#g; s#~!THUMBNAIL!~#$thumbnail#g" \
        > "$itemFileOut"
    
    replaceLine "$itemFileOut" '~!ITEMTAGS!~' "$tagBar"
}

function generateRelated
{
    # Thisi is assumed to be called from inside intermediate/tags
    local tag="$1"
    local outputDir="../related/$tag"
    local outputFile="$outputDir/README.md"
    
    if [ ! -e "$outputFile" ]; then
        mkdir -p "$outputDir"
        cat "../../src/templates/relatedTag.md" | sed "s#~!MYTAG!~#$tag#g" > "$outputFile"
    fi
}

function replaceLine
{
    local fileName="$1"
    local search="$2"
    local replace="$3"
    
    rm -f "$fileName.replace"
    touch "$fileName.replace"
    while read -r line; do
        if [ "$line" != "$search" ]; then
            echo "$line" >> "$fileName.replace"
        else
            echo "$replace" >> "$fileName.replace"
        fi
    done < <(cat "$fileName")
    
    rm "$fileName"
    mv "$fileName.replace" "$fileName"
}

function getImageName
{
    local inputName="$1"
    local suffix="$2"
    
    local extension="$(echo "$inputName" | sed 's/^.*\.//g')"
    local name="$(echo "$inputName" | sed "s/\.$extension$//g")"
    
    echo "$name$suffix.$extension"
}

function makeThumbnail
{
    local inFile="$1"
    local outFile="$2"
    
    if [ ! -f "$outFile" ]; then
        mkdir -p "$(dirname "$outFile")"
        convert -resize "$thumbnailSize" "$inFile" "$outFile"
    fi
}

function buildRSSFeeds
{
    echo "buildRSSFeeds"
    while read -r feed; do
        _buildRSSFeed "$feed" &
    done
    wait
}

function _buildRSSFeed
{
    local feedName="$1"
    local fileName="build/rss/$feedName.rss"
    
    [ "$doDebug" -gt 0 ] && echo "Build feed $feedName."
    
    cat "src/templates/head.rss" | \
        sed "s#~!SITETITLE!~#$siteTitle#g; s#~!SITEDESCRIPTION!~#$siteDescription#g; s#~!SITEURL!~#$siteURL#g; s#~!MYTAG!~#$feedName#g;" \
        > "$fileName"
    
    cat "intermediate/feed/$feedName" >> "$fileName"
    
    cat "src/templates/foot.rss" \
        >> "$fileName"
}

function getTagBar
{
    local tags="$1"
    local type="$2"
    local tagBarFile="../intermediate/tagBar/bars/$tags.$type"
    
    buildTagBar "$tags" "$type"
    cat "$tagBarFile"
}

function buildTagBar
{
    local tags="$1"
    local type="$2"
    local tagBarFile="../intermediate/tagBar/bars/$tags.$type"
    
    if [ ! -f "$tagBarFile" ]; then
        tagsContents="$(_buildTags "$tags" "$type" | _buildTagsGetContents)"
        # echo "DEBUG $tagsContents" >&2
        
        cat "../src/templates/tagBar.$type" | \
            sed "s#~!TAGS!~#$tagsContents#g" \
            > "$tagBarFile"
    fi
}

function _buildTagsGetContents
{
    while read -r fileIn; do
        cat "$fileIn"
    done | tr '\n' ',' | sed 's/,//g' # TODO This is a terrible hack to get rid of \n.
}

function _buildTags
{
    local tags="$1"
    local type="$2"
    
    # TODO Do this better. Eg it won't handle tags with spaces (which shouldn't happen anyway...). Check if IFS will work here.
    for tag in $(echo $tags | sed 's/,/ /g'); do
        tagFileName="../intermediate/tagBar/tags/$tag.$type"
        buildTag "$tag" "$type" "$tagFileName"
        echo "$tagFileName"
    done
}

function buildTag
{
    local tag="$1"
    local type="$2"
    local tagFileName="$3"
    
    cat "../src/templates/tag.$type" | \
        sed "s#~!TAG!~#$tag#g" \
        > "$tagFileName"
    
}

function addDocToTags
{
    local doc="$1"
    local date="$2"
    local tags="$3"
    
    IFS=","
    
    for tag in $tags; do
        addDocToTag "$doc" "$date" $tag
    done
    
    IFS=" "
}

function addDocToTag
{
    # This is assumed to be  run from inside addDocToTags, inside buildDocs. Therefore the it will be executed inside the ./build directory, so all paths are relative to that.
    local tagPath="../intermediate/tags"
    
    local doc="$1"
    local date="$2"
    local tag="$3"
    
    if [ "$doc" == '' ] || [ "$date" == '' ] || [ "$tag" == '' ] ; then
        echo "Could not add doc '$doc' to tag '$tag' on date '$date'." >&2
        return 1
    else
        echo "$date $doc" >> "$tagPath/$tag.raw"
    fi
}

function sortTags
{
    cd  intermediate/tags
    
    echo -n "Sorting tags..."
    for tag in *.raw;do
        sort -ur "$tag" > "$tag.sorted"
        shortTag="$(echo "$tag" | sed 's/\.raw$//g')"
        mv "$tag.sorted" "$shortTag"
        rm "$tag"
        
        generateRelated "$shortTag"
    done
    wait
    echo "Done."
    
    cd ../.. # TODO Is this really needed?
}

function getUniqueTags
{
    local tags="$1"
    echo "$tags" | sed 's/,/\n/g' | sort -u | grep -v '^$' | tr '\n' ',' | sed 's/,$//g'
}

function saveTagCombo
{
    # Assumed to be called within the prep. So inside the ./build directory.
    local tagCombo="$1"
    touch "../intermediate/tagCombos/$tagCombo"
}

function fillTagCombos
{
    # Assumed to be called from the script root. So not inside any sub-directory.
    cd intermediate/tagCombos
    
    echo "fillTagCombos."
    for tagCombo in *; do
        [ "$doDebug" -gt 0 ] && echo "Fill tagCombo $tagCombo."
        for tag in $(echo $tagCombo | sed 's/,/\n/g'); do
            [ "$doDebug" -gt 1 ] && echo "  $tag" >&2
            cat "../tags/$tag"
        done | sort -ru > "$tagCombo"
    done
    
    cd ~-
}

function buildPreview
{
    local inFile="$1"
    local outFile="$2"
    
    value="$(grep -v '\(^<!-- \|^$\|^#\|^!\|^\[\|^----\|^====\|^\\\\\|^.$\|^http\)' "$inFile"| tr ' ' '\n' | head -n "$previewLength" | tr '\n' ' ' | sed 's/[<>/]//g')"
    
    echo "$value" > "$outFile"
}

function images
{
    local myTag="$1"
    
    while read -r line;do
        if [ "${line::2}" == '![' ]; then
            description="$(echo "$line" | sed 's/^..//g; s/\].*$//g')"
            file="$(echo "$line" | sed 's/^.*(//g; s/).*$//g')"
            
            previewFile="$(getImageName "$file" "_preview")"
            imageFile="$(getImageName "$file" "_viewable")"
            
            if [ -f "$myTag/$file" ]; then
                imageMaxSize "$myTag/$file" "$myTag/$previewFile" "$previewMaxSize"
                imageMaxSize "$myTag/$file" "$myTag/$imageFile" "$useableMaxSize"
                
                rm "$myTag/$file"
            fi
            
            if [ -f "$myTag/$previewFile" ] && [ -f "$myTag/$imageFile" ] ; then
                echo "<p><a href=\"$imageFile\" target=\"_blank\"><img alt=\"$description\" src=\"$previewFile\" /></a><br>Above: $description</p>"
            else
                echo "Could not find \"$myTag/$previewFile\" & \"$myTag/$imageFile\" in \"$(pwd)\". So this has been skipped in the final output." >&2
            fi
        else
            echo "$line"
        fi
    done
}

function imageMaxSize
{
    local imageInFile="$1"
    local imageOutFile="$2"
    local imageMaxSize="$3"
    
    if [ -e "$imageOutFile" ]; then
        true # Don't do anything if we already have it. This can be re-done by doing a ./bin/freshBuild
    elif [ -e "$imageInFile" ]; then
        read x y < <(identify -format "%w %h" "$imageInFile")
        
        if [ $x -gt $y ]; then
            if [ "$x" -gt "$imageMaxSize" ]; then
                let newY=$y*$imageMaxSize/$x
                convert -resize "${imageMaxSize}x${newY}" "$imageInFile" "$imageOutFile"
            else
                cp "$imageInFile" "$imageOutFile"
            fi
        else
            if [ "$y" -gt "$imageMaxSize" ]; then
                let newX=$x*$imageMaxSize/$y
                convert -resize "${newY}x${imageMaxSize}" "$imageInFile" "$imageOutFile"
            else
                cp "$imageInFile" "$imageOutFile"
            fi
        fi
    else
        echo "imageMaxSize: Could not find \"$imageInFile\"." >&2
    fi
}

function videos
{
    while read -r line; do
        if [ "${line::29}" == "https://www.youtube.com/watch" ] || [ "${line::28}" == "http://www.youtube.com/watch" ]; then
            id="$(echo "$line" | sed 's/^.*v=//g;s/&.*$//g')"
            echo '<iframe class="video" width="560" height="315" src="https://www.youtube.com/embed/'"$id"'" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>'
        elif [ "${line::18}" == 'https://vimeo.com/' ]; then
            id="$(echo "$line" | cut -d/ -f4)"
            echo '<iframe src="https://player.vimeo.com/video/'"$id"'" class="video" width="640" height="360" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>'
        else
            echo "$line"
        fi
    done
}

function getLists
{
    local listsLocation="$1"
    cd "$listsLocation"
    ls -1
    cd ~-
}

function buildList
{
    # This is intended to be run from the script root. So no sub directories.
    #rss build/rss 10
    local listOrigin="$1"
    local type="$2"
    local destination="$3"
    local limit="$4"
    
    echo "buildList"
    while read -r feed; do
        _buildList "$feed" &
    done
    wait
}

function _buildList
{
    local feed="$1"
    
    [ "$doDebug" -gt 0 ] && echo "Build feed contents $feed."
    
    filePath="$destination/$feed"
    rm -f "$filePath"
    while read -r releaseDate item; do
        cat intermediate/$type/$item >> "$filePath"
    done < <(cat "$listOrigin/$feed")
}

function deriveLatest
{
    head -n "$howManyPostsOnRoot" intermediate/tags/all > intermediate/tags/latest
}

function copyAssets
{
    for asset in img js css; do
        if [ -e "src/site/$asset" ]; then
            echo "Copying $asset."
            rsync -r "src/site/$asset" build/ &
        else
            echo "Skipping $asset."
        fi
    done
}

function findSubAssets
{
    cd src/site
    find | grep -v '\(/$\|.md$\)' | cut -b3-
}

function copySubAssets
{
    cd build
    while read fileIn; do
        mkdir -p "$(dirname "$fileIn")"
        if [ ! -d "../src/site/$fileIn" ]; then
            cp "../src/site/$fileIn" "$fileIn"
        fi
    done
}

function findSymlinks
{
    cd src/site
    find . -type l | cut -b3-
    cd .. # TODO Is this really needed?
}

function copySymlinks
{
    cd build
    echo "Copying symlinks."
    while read -r symlink; do
        subDir="$(dirname "$symlink")"
        if [ "$subDir" != '.' ]; then
            mkdir -p "$subDir"
        fi
        
        if [ ! -f "$symlink" ]; then
            cp -P "../src/site/$symlink" "$symlink"
        fi
    done
}

rm -Rf ../intermediate
mkdir -p build
copyAssets
findSubAssets | copySubAssets &
getDocs | prepDocs
sortTags
deriveLatest
fillTagCombos
getLists intermediate/tags | buildList intermediate/tags rss intermediate/feed 10
getLists intermediate/tags | buildList intermediate/tags html intermediate/list 100000
getLists intermediate/tagCombos | buildList intermediate/tagCombos html intermediate/list 100000
getLists intermediate/tags | buildRSSFeeds
find intermediate/related -type f | buildDocs
getDocs | buildDocs
findSymlinks | copySymlinks

# TODO Do lowercase symlinks.
# TODO Honour build date.
# TODO Add test flag.
# TODO Mark test both ways.
# TODO Make tags clickable.
